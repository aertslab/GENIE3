% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/GENIE3.R
\name{GENIE3}
\alias{GENIE3}
\alias{GENIE3,matrix-method}
\alias{GENIE3,SummarizedExperiment-method}
\alias{GENIE3,ExpressionSet-method}
\title{GENIE3}
\usage{
GENIE3(
  exprMatrix,
  regulators = NULL,
  targets = NULL,
  treeMethod = "RF",
  K = "sqrt",
  nTrees = 1000,
  nCores = 1,
  returnMatrix = TRUE,
  verbose = FALSE
)

\S4method{GENIE3}{matrix}(
  exprMatrix,
  regulators = NULL,
  targets = NULL,
  treeMethod = "RF",
  K = "sqrt",
  nTrees = 1000,
  nCores = 1,
  returnMatrix = TRUE,
  verbose = FALSE
)

\S4method{GENIE3}{SummarizedExperiment}(
  exprMatrix,
  regulators = NULL,
  targets = NULL,
  treeMethod = "RF",
  K = "sqrt",
  nTrees = 1000,
  nCores = 1,
  returnMatrix = TRUE,
  verbose = FALSE
)

\S4method{GENIE3}{ExpressionSet}(
  exprMatrix,
  regulators = NULL,
  targets = NULL,
  treeMethod = "RF",
  K = "sqrt",
  nTrees = 1000,
  nCores = 1,
  returnMatrix = TRUE,
  verbose = FALSE
)
}
\arguments{
\item{exprMatrix}{Expression matrix (genes x samples). Every row is a gene, every column is a sample.
The expression matrix can also be provided as one of the Bioconductor classes:
\itemize{
\item \code{ExpressionSet}: The matrix will be obtained through exprs(exprMatrix)
\item \code{RangedSummarizedExperiment}: The matrix will be obtained through assay(exprMatrix), wich will extract the first assay (usually the counts)
}}

\item{regulators}{Subset of genes used as candidate regulators. Must be either a vector of gene names, e.g. \code{c("at_12377", "at_10912")} or a vector of indices, e.g. \code{c(1,5,6,7)}. 
The default value NULL means that all the genes are used as candidate regulators (which is NOT recommended). To provide different regulators for each gene, providethem as named list.}

\item{targets}{Subset of genes to which potential regulators will be calculated. Must be either a vector of indices, e.g. \code{c(1,5,6,7)}, or a vector of gene names, e.g. \code{c("at_12377", "at_10912")}. If NULL (default), regulators will be calculated for all genes in the input matrix.}

\item{treeMethod}{Tree-based method used. Must be either "RF" for Random Forests (default) or "ET" for Extra-Trees.}

\item{K}{Number of candidate regulators randomly selected at each tree node (for the determination of the best split). Must be either "sqrt" for the square root of the total number of candidate regulators (default), "all" for the total number of candidate regulators, or a stricly positive integer.}

\item{nTrees}{Number of trees in an ensemble for each target gene. Default: 1000.}

\item{nCores}{Number of cores to use for parallel computing. Default: 1.}

\item{returnMatrix}{Returns output as weight matrix (TRUE). Otherwise (FALSE) it is returned as a list.}

\item{verbose}{If set to TRUE, a feedback on the progress of the calculations is given. Default: FALSE.}
}
\value{
Weighted adjacency matrix of inferred network. Element w_ij (row i, column j) gives the importance of the link from regulatory gene i to target gene j.
}
\description{
\code{GENIE3} Infers a gene regulatory network (in the form of a weighted adjacency matrix) from expression data, using ensembles of regression trees.
}
\examples{
## Generate fake expression matrix
exprMatrix <- matrix(sample(1:10, 100, replace=TRUE), nrow=20)
rownames(exprMatrix) <- paste("Gene", 1:20, sep="")
colnames(exprMatrix) <- paste("Sample", 1:5, sep="")

## Run GENIE3
set.seed(123) # For reproducibility of results
weightMatrix <- GENIE3(exprMatrix, regulators=paste("Gene", 1:5, sep=""))

## Get ranking of edges
linkList <- getLinkList(weightMatrix)
head(linkList)

## Different regulators for each gene & return as list
regulatorsList <- list("Gene1"=rownames(exprMatrix)[1:10],
                       "Gene2"=rownames(exprMatrix)[10:20],
                       "Gene20"=rownames(exprMatrix)[15:20])

set.seed(123)
weightList <- GENIE3(exprMatrix, nCores=1, targets=names(regulatorsList), regulators=regulatorsList, returnMatrix=FALSE)
}
